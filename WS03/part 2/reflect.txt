q1. In the book class, i added a display function print to format book details, getters to access private member variables and comparison operators (< and >), use to compare the average pages per chapter for ordering.


q2. getSmallestItem and getLargestItem are not pure query functions, even though they do not change values, because they access static class attributes shared by all instances of the class. These attributes are like a global state within the class, and their values depend on the class's internal rules to keep them updated based on actions from any instance.

q3. I tried to make operator[] in the Collection module a query by changing it to return const T&, which means read-only. This worked for reading items but did not let me change items in derived classes. Derived classes need to modify items for tasks like sorting or updating. So, I found out that operator[] should stay as a mutator to allow these changes.

One of the challenges I faced during this workshop was getting the comparison operators for the Book class to work properly. To fix this, I defined the < and > operators inside the Book class to compare the average pages per chapter. The reason for defining class objects outside the class definition is to allow proper initialization and ensure they are shared across all instances of the class. Specializing m_smallestItem and m_largestItem for Book and 10 ensures they have the right starting values for the Book type, like {"", 1, 10000} for the smallest item and {"", 10000, 1} for the largest item, which helps in identifying the smallest and largest Book objects correctly. Initializing m_smallestItem and m_largestItem for Book and 72 is also necessary for cases where the collection capacity is 72, ensuring Book objects have valid starting values when the capacity is different, and keeping the behavior of the Collection class consistent.
